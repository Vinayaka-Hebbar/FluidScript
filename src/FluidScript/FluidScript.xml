<?xml version="1.0"?>
<doc>
    <assembly>
        <name>FluidScript</name>
    </assembly>
    <members>
        <member name="T:FluidScript.Compiler.Binders.IBinder">
            <summary>
            Binder for variable or member
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.Binders.IBinder.CanEmitThis">
            <summary>
            From this you can identify whether Binder is a Variable or Static Member 
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.Binders.IBinder.IsMember">
            <summary>
             From this you can identify whether Binder is a Variable or Member 
            </summary>
        </member>
        <member name="T:FluidScript.Compiler.Binders.RuntimeVariableBinder">
            <summary>
            IL generator for <see cref="T:FluidScript.Compiler.RuntimeVariables"/>
            </summary>
        </member>
        <member name="T:FluidScript.Compiler.CompilerBase">
            <summary>
            Compiler base implementation
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.CompilerBase.VisitConvert(FluidScript.Compiler.SyntaxTree.ConvertExpression)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Debugging.TextPosition.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new SourceCodePosition instance.
            </summary>
            <param name="line"> The line number. Must be greater than zero. </param>
            <param name="column"> The column number. Must be greater than zero. </param>
        </member>
        <member name="P:FluidScript.Compiler.Debugging.TextPosition.Line">
            <summary>
            Gets the line number.
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.Debugging.TextPosition.Column">
            <summary>
            Gets the column number.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Debugging.TextSpan.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new SourceCodeSpan instance.
            </summary>
            <param name="startLine"> The start line of this SourceCodeSpan. Must be greater than
            zero. </param>
            <param name="startColumn"> The start column of this SourceCodeSpan. Must be greater
            than zero. </param>
            <param name="endLine"> The end line of this SourceCodeSpan. Must be greater than
            <paramref name="startLine"/>. </param>
            <param name="endColumn"> The end column of this SourceCodeSpan. Must be greater than
            <paramref name="startColumn"/>. </param>
        </member>
        <member name="M:FluidScript.Compiler.Debugging.TextSpan.#ctor(FluidScript.Compiler.Debugging.TextPosition,FluidScript.Compiler.Debugging.TextPosition)">
            <summary>
            Creates a new SourceCodeSpan instance.
            </summary>
            <param name="start"> The start line and column of this SourceCodeSpan. </param>
            <param name="end"> The end line and column of this SourceCodeSpan. </param>
        </member>
        <member name="P:FluidScript.Compiler.Debugging.TextSpan.StartLine">
            <summary>
            Gets the starting line number of this range.
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.Debugging.TextSpan.StartColumn">
            <summary>
            Gets the starting column number of this range.
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.Debugging.TextSpan.EndLine">
            <summary>
            Gets the ending line number of this range.
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.Debugging.TextSpan.EndColumn">
            <summary>
            Gets the ending column number of this range.
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.Emit.AssemblyGen.LanguageType">
            <summary>
            Gets the language type GUID for the symbol store.
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.Emit.AssemblyGen.LanguageVendor">
            <summary>
            Gets the language vendor GUID for the symbol store.
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.Emit.AssemblyGen.DocumentType">
            <summary>
            Gets the document type GUID for the symbol store.
            </summary>
        </member>
        <member name="T:FluidScript.Compiler.Emit.ILGenerator">
            <summary>
            Represents a generator of CIL bytes.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.Complete">
            <summary>
            Emits a return statement and finalizes the generated code.  Do not emit any more
            instructions after calling this method.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.Pop">
            <summary>
            Pops the value from the top of the stack.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.Duplicate">
            <summary>
            Duplicates the value on the top of the stack.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.CreateLabel">
            <summary>
            Creates a label without setting its position.
            </summary>
            <returns> A new label. </returns>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.DefineLabelPosition(FluidScript.Compiler.Emit.ILLabel)">
            <summary>
            Defines the position of the given label.
            </summary>
            <param name="label"> The label to define. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.DefineLabelPosition">
            <summary>
            Creates a label and sets its position.
            </summary>
            <returns> A new label. </returns>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.Branch(FluidScript.Compiler.Emit.ILLabel)">
            <summary>
            Unconditionally branches to the given label.
            </summary>
            <param name="label"> The label to branch to. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.BranchIfZero(FluidScript.Compiler.Emit.ILLabel)">
            <summary>
            Branches to the given label if the value on the top of the stack is zero, false or
            null.
            </summary>
            <param name="label"> The label to branch to. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.BranchIfNotZero(FluidScript.Compiler.Emit.ILLabel)">
            <summary>
            Branches to the given label if the value on the top of the stack is non-zero, true or
            non-null.
            </summary>
            <param name="label"> The label to branch to. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.BranchIfFalse(FluidScript.Compiler.Emit.ILLabel)">
            <summary>
            Branches to the given label if the value on the top of the stack is zero, false or
            null.
            </summary>
            <param name="label"> The label to branch to. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.BranchIfTrue(FluidScript.Compiler.Emit.ILLabel)">
            <summary>
            Branches to the given label if the value on the top of the stack is non-zero, true or
            non-null.
            </summary>
            <param name="label"> The label to branch to. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.BranchIfNull(FluidScript.Compiler.Emit.ILLabel)">
            <summary>
            Branches to the given label if the value on the top of the stack is zero, false or
            null.
            </summary>
            <param name="label"> The label to branch to. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.BranchIfNotNull(FluidScript.Compiler.Emit.ILLabel)">
            <summary>
            Branches to the given label if the value on the top of the stack is non-zero, true or
            non-null.
            </summary>
            <param name="label"> The label to branch to. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.BranchIfEqual(FluidScript.Compiler.Emit.ILLabel)">
            <summary>
            Branches to the given label if the two values on the top of the stack are equal.
            </summary>
            <param name="label"> The label to branch to. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.BranchIfNotEqual(FluidScript.Compiler.Emit.ILLabel)">
            <summary>
            Branches to the given label if the two values on the top of the stack are not equal.
            </summary>
            <param name="label"> The label to branch to. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.BranchIfGreaterThan(FluidScript.Compiler.Emit.ILLabel)">
            <summary>
            Branches to the given label if the first value on the stack is greater than the second
            value on the stack.
            </summary>
            <param name="label"> The label to branch to. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.BranchIfGreaterThanUnsigned(FluidScript.Compiler.Emit.ILLabel)">
            <summary>
            Branches to the given label if the first value on the stack is greater than the second
            value on the stack.  If the operands are integers then they are treated as if they are
            unsigned.  If the operands are floating point numbers then a NaN value will trigger a
            branch.
            </summary>
            <param name="label"> The label to branch to. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.BranchIfGreaterThanOrEqual(FluidScript.Compiler.Emit.ILLabel)">
            <summary>
            Branches to the given label if the first value on the stack is greater than or equal to
            the second value on the stack.
            </summary>
            <param name="label"> The label to branch to. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.BranchIfGreaterThanOrEqualUnsigned(FluidScript.Compiler.Emit.ILLabel)">
            <summary>
            Branches to the given label if the first value on the stack is greater than or equal to
            the second value on the stack.  If the operands are integers then they are treated as
            if they are unsigned.  If the operands are floating point numbers then a NaN value will
            trigger a branch.
            </summary>
            <param name="label"> The label to branch to. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.BranchIfLessThan(FluidScript.Compiler.Emit.ILLabel)">
            <summary>
            Branches to the given label if the first value on the stack is less than the second
            value on the stack.
            </summary>
            <param name="label"> The label to branch to. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.BranchIfLessThanUnsigned(FluidScript.Compiler.Emit.ILLabel)">
            <summary>
            Branches to the given label if the first value on the stack is less than the second
            value on the stack.  If the operands are integers then they are treated as if they are
            unsigned.  If the operands are floating point numbers then a NaN value will trigger a
            branch.
            </summary>
            <param name="label"> The label to branch to. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.BranchIfLessThanOrEqual(FluidScript.Compiler.Emit.ILLabel)">
            <summary>
            Branches to the given label if the first value on the stack is less than or equal to
            the second value on the stack.
            </summary>
            <param name="label"> The label to branch to. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.BranchIfLessThanOrEqualUnsigned(FluidScript.Compiler.Emit.ILLabel)">
            <summary>
            Branches to the given label if the first value on the stack is less than or equal to
            the second value on the stack.  If the operands are integers then they are treated as
            if they are unsigned.  If the operands are floating point numbers then a NaN value will
            trigger a branch.
            </summary>
            <param name="label"> The label to branch to. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.Return">
            <summary>
            Returns from the current method.  A value is popped from the stack and used as the
            return value.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.Switch(FluidScript.Compiler.Emit.ILLabel[])">
            <summary>
            Creates a jump table.  A value is popped from the stack - this value indicates the
            index of the label in the <paramref name="labels"/> array to jump to.
            </summary>
            <param name="labels"> A array of labels. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.DeclareVariable(System.Type,System.String,System.Boolean)">
            <summary>
            Declares a new local variable.
            </summary>
            <param name="type"> The type of the local variable. </param>
            <param name="name"> The name of the local variable. Can be <c>null</c>. </param>
            <param name="pinned">true to pin the object in memory; otherwise, false. </param>
            <returns> A new local variable. </returns>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.LoadVariable(FluidScript.Compiler.Emit.ILLocalVariable)">
            <summary>
            Pushes the value of the given variable onto the stack.
            </summary>
            <param name="variable"> The variable whose value will be pushed. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.LoadAddressOfVariable(FluidScript.Compiler.Emit.ILLocalVariable)">
            <summary>
            Pushes the address of the given variable onto the stack.
            </summary>
            <param name="variable"> The variable whose address will be pushed. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.StoreVariable(FluidScript.Compiler.Emit.ILLocalVariable)">
            <summary>
            Pops the value from the top of the stack and stores it in the given local variable.
            </summary>
            <param name="variable"> The variable to store the value. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.LoadArgument(System.Int32)">
            <summary>
            Pushes the value of the method argument with the given index onto the stack.
            </summary>
            <param name="argumentIndex"> The index of the argument to push onto the stack. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.LoadAddressOfArgument(System.Int32)">
            <summary>
            Pushes the address of the given argument onto the stack.
            </summary>
            <param name="argumentIndex"> The parameter index whose address will be pushed. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.StoreArgument(System.Int32)">
            <summary>
            Pops a value from the stack and stores it in the method argument with the given index.
            </summary>
            <param name="argumentIndex"> The index of the argument to store into. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.CreateTemporaryVariable(System.Type)">
            <summary>
            Creates temp ILVariab le
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.ReleaseTemporaryVariable(FluidScript.Compiler.Emit.ILLocalVariable)">
            <summary>
            Indicates that the given temporary variable is no longer needed.
            </summary>
            <param name="variable"> The temporary variable created using CreateTemporaryVariable(). </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.LoadNull">
            <summary>
            Pushes <c>null</c> onto the stack.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.LoadBool(System.Boolean)">
            <summary>
            Pushes a bool constant value onto the stack.
            </summary>
            <param name="value"> The bool to push onto the stack. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.LoadByte(System.Byte)">
            <summary>
            Pushes a unsigned byte constant value onto the stack.
            </summary>
            <param name="value"> The unsigned byte to push onto the stack. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.LoadByte(System.SByte)">
            <summary>
            Pushes a byte constant value onto the stack.
            </summary>
            <param name="value"> The signed byte to push onto the stack. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.LoadInt16(System.Int16)">
            <summary>
            Pushes a short constant value onto the stack.
            </summary>
            <param name="value"> The 16 bit integer to push onto the stack. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.LoadInt16(System.UInt16)">
            <summary>
            Pushes a unsigned short constant value onto the stack.
            </summary>
            <param name="value"> The 16 bit unsigned integer to push onto the stack. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.LoadInt32(System.Int32)">
            <summary>
            Pushes a int constant value onto the stack.
            </summary>
            <param name="value"> The 32 bit integer to push onto the stack. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.LoadInt32(System.UInt32)">
            <summary>
            Pushes a unsigned int constant value onto the stack.
            </summary>
            <param name="value"> The 32 bit unsigned integer to push onto the stack. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.LoadInt64(System.Int64)">
            <summary>
            Pushes a long constant value onto the stack.
            </summary>
            <param name="value"> The 64 bit integer to push onto the stack. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.LoadInt64(System.UInt64)">
            <summary>
            Pushes a unsigned long constant value onto the stack.
            </summary>
            <param name="value"> The 64 bit unsigned integer to push onto the stack. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.LoadSingle(System.Single)">
            <summary>
            Pushes a float constant value onto the stack.
            </summary>
            <param name="value"> The float to push onto the stack. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.LoadDouble(System.Double)">
            <summary>
            Pushes a double constant value onto the stack.
            </summary>
            <param name="value"> The double to push onto the stack. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.LoadChar(System.Char)">
            <summary>
            Pushes a char constant value onto the stack.
            </summary>
            <param name="value"> The char to push onto the stack. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.LoadString(System.String)">
            <summary>
            Pushes a string constant value onto the stack.
            </summary>
            <param name="value"> The string to push onto the stack. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.CompareEqual">
            <summary>
            Pops two values from the stack, compares, then pushes <c>1</c> if the first argument
            is equal to the second, or <c>0</c> otherwise.  Produces <c>0</c> if one or both
            of the arguments are <c>NaN</c>.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.CompareGreaterThan">
            <summary>
            Pops two values from the stack, compares, then pushes <c>1</c> if the first argument
            is greater than the second, or <c>0</c> otherwise.  Produces <c>0</c> if one or both
            of the arguments are <c>NaN</c>.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.CompareGreaterThanUnsigned">
            <summary>
            Pops two values from the stack, compares, then pushes <c>1</c> if the first argument
            is greater than the second, or <c>0</c> otherwise.  Produces <c>1</c> if one or both
            of the arguments are <c>NaN</c>.  Integers are considered to be unsigned.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.CompareLessThan">
            <summary>
            Pops two values from the stack, compares, then pushes <c>1</c> if the first argument
            is less than the second, or <c>0</c> otherwise.  Produces <c>0</c> if one or both
            of the arguments are <c>NaN</c>.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.CompareLessThanUnsigned">
            <summary>
            Pops two values from the stack, compares, then pushes <c>1</c> if the first argument
            is less than the second, or <c>0</c> otherwise.  Produces <c>1</c> if one or both
            of the arguments are <c>NaN</c>.  Integers are considered to be unsigned.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.Add">
            <summary>
            Pops two values from the stack, adds them together, then pushes the result to the
            stack.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.Subtract">
            <summary>
            Pops two values from the stack, subtracts the second from the first, then pushes the
            result to the stack.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.Multiply">
            <summary>
            Pops two values from the stack, multiplies them together, then pushes the
            result to the stack.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.Divide">
            <summary>
            Pops two values from the stack, divides the first by the second, then pushes the
            result to the stack.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.Remainder">
            <summary>
            Pops two values from the stack, divides the first by the second, then pushes the
            remainder to the stack.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.Negate">
            <summary>
            Pops a value from the stack, negates it, then pushes it back onto the stack.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.BitwiseAnd">
            <summary>
            Pops two values from the stack, ANDs them together, then pushes the result to the
            stack.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.BitwiseOr">
            <summary>
            Pops two values from the stack, ORs them together, then pushes the result to the
            stack.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.BitwiseXor">
            <summary>
            Pops two values from the stack, XORs them together, then pushes the result to the
            stack.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.BitwiseNot">
            <summary>
            Pops a value from the stack, inverts it, then pushes the result to the stack.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.ShiftLeft">
            <summary>
            Pops two values from the stack, shifts the first to the left, then pushes the result
            to the stack.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.ShiftRight">
            <summary>
            Pops two values from the stack, shifts the first to the right, then pushes the result
            to the stack.  The sign bit is preserved.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.ShiftRightUnsigned">
            <summary>
            Pops two values from the stack, shifts the first to the right, then pushes the result
            to the stack.  The sign bit is not preserved.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.Box(System.Type)">
            <summary>
            Pops a value from the stack, converts it to an object reference, then pushes it back onto
            the stack.
            </summary>
            <param name="type"> The type of value to box.  This should be a value type. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.Unbox(System.Type)">
            <summary>
            Pops an object reference (representing a boxed value) from the stack, extracts the
            address, then pushes that address onto the stack.
            </summary>
            <param name="type"> The type of the boxed value.  This should be a value type. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.UnboxObject(System.Type)">
            <summary>
            Pops an object reference (representing a boxed value) from the stack, extracts the value,
            then pushes the value onto the stack.
            </summary>
            <param name="type"> The type of the boxed value.  This should be a value type. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.ConvertToBool">
            <summary>
            Pops a value from the stack, converts it to a bool, then pushes it back onto
            the stack.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.ConvertToByte">
            <summary>
            Pops a value from the stack, converts it to a signed byte, then pushes it back onto
            the stack.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.ConvertToUnsignedByte">
            <summary>
            Pops a value from the stack, converts it to a unsigned byte, then pushes it back onto
            the stack.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.ConvertToInt16">
            <summary>
            Pops a value from the stack, converts it to a signed short, then pushes it back onto
            the stack.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.ConvertToUnsignedInt16">
            <summary>
            Pops a value from the stack, converts it to a unsigned short, then pushes it back onto
            the stack.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.ConvertToInt32">
            <summary>
            Pops a value from the stack, converts it to a signed integer, then pushes it back onto
            the stack.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.ConvertToUnsignedInt32">
            <summary>
            Pops a value from the stack, converts it to a unsigned integer, then pushes it back onto
            the stack.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.ConvertToInt64">
            <summary>
            Pops a value from the stack, converts it to a signed long, then pushes it back onto
            the stack.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.ConvertToUnsignedInt64">
            <summary>
            Pops a value from the stack, converts it to a unsigned long, then pushes it back onto
            the stack.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.ConvertToChar">
            <summary>
            Pops a value from the stack, converts it to a char, then pushes it back onto
            the stack.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.ConvertToSingle">
            <summary>
            Pops a value from the stack, converts it to a float, then pushes it back onto
            the stack.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.ConvertToDouble">
            <summary>
            Pops a value from the stack, converts it to a double, then pushes it back onto
            the stack.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.NewObject(System.Reflection.ConstructorInfo)">
            <summary>
            Pops the constructor arguments off the stack and creates a new instance of the object.
            </summary>
            <param name="constructor"> The constructor that is used to initialize the object. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.Call(System.Reflection.MethodBase)">
            <summary>
            Pops the method arguments off the stack, calls the given method, then pushes the result
            to the stack (if there was one).  Identical to CallStatic() if the method is a static
            method (or is declared on a value type) or CallVirtual() otherwise.
            </summary>
            <param name="method"> The method to call. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.CallStatic(System.Reflection.MethodBase)">
            <summary>
            Pops the method arguments off the stack, calls the given method, then pushes the result
            to the stack (if there was one).  This operation can be used to call instance methods,
            but virtual overrides will not be called and a null check will not be performed at the
            callsite.
            </summary>
            <param name="method"> The method to call. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.CallVirtual(System.Reflection.MethodBase)">
            <summary>
            Pops the method arguments off the stack, calls the given method, then pushes the result
            to the stack (if there was one).  This operation cannot be used to call static methods.
            Virtual overrides are obeyed and a null check is performed.
            </summary>
            <param name="method"> The method to call. </param>
            <exception cref="T:System.ArgumentException"> The method is static. </exception>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.LoadField(System.Reflection.FieldInfo)">
            <summary>
            Pushes the value of the given field onto the stack.
            </summary>
            <param name="field"> The field whose value will be pushed. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.StoreField(System.Reflection.FieldInfo)">
            <summary>
            Pops a value off the stack and stores it in the given field.
            </summary>
            <param name="field"> The field to modify. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.CastClass(System.Type)">
            <summary>
            Pops an object off the stack, checks that the object inherits from or implements the
            given type, and pushes the object onto the stack if the check was successful or
            throws an InvalidCastException if the check failed.
            </summary>
            <param name="type"> The type of the class the object inherits from or the interface the
            object implements. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.IsInstance(System.Type)">
            <summary>
            Pops an object off the stack, checks that the object inherits from or implements the
            given type, and pushes either the object (if the check was successful) or <c>null</c>
            (if the check failed) onto the stack.
            </summary>
            <param name="type"> The type of the class the object inherits from or the interface the
            object implements. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.LoadToken(System.Type)">
            <summary>
            Pushes a RuntimeTypeHandle corresponding to the given type onto the evaluation stack.
            </summary>
            <param name="type"> The type to convert to a RuntimeTypeHandle. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.LoadToken(System.Reflection.MethodBase)">
            <summary>
            Pushes a RuntimeMethodHandle corresponding to the given method onto the evaluation
            stack.
            </summary>
            <param name="method"> The method to convert to a RuntimeMethodHandle. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.LoadToken(System.Reflection.FieldInfo)">
            <summary>
            Pushes a RuntimeFieldHandle corresponding to the given field onto the evaluation stack.
            </summary>
            <param name="field"> The type to convert to a RuntimeFieldHandle. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.LoadStaticMethodPointer(System.Reflection.MethodBase)">
            <summary>
            Pushes a pointer to the native code implementing the given method onto the evaluation
            stack.  The virtual qualifier will be ignored, if present.
            </summary>
            <param name="method"> The method to retrieve a pointer for. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.LoadVirtualMethodPointer(System.Reflection.MethodBase)">
            <summary>
            Pushes a pointer to the native code implementing the given method onto the
            evaluation stack.  This method cannot be used to retrieve a pointer to a static method.
            </summary>
            <param name="method"> The method to retrieve a pointer for. </param>
            <exception cref="T:System.ArgumentException"> The method is static. </exception>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.LoadMethodPointer(System.Reflection.MethodBase)">
            <summary>
            Pushes a pointer to the native code implementing the given method onto the evaluation
            stack.  This method is identical to LoadStaticMethodPointer() if the method is a static
            method (or is declared on a value type) or LoadVirtualMethodPointer() otherwise.
            </summary>
            <param name="method"> The method to retrieve a pointer for. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.InitObject(System.Type)">
            <summary>
            Pops a managed or native pointer off the stack and initializes the referenced type with
            zeros.
            </summary>
            <param name="type"> The type the pointer on the top of the stack is pointing to. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.NewArray(System.Type)">
            <summary>
            Pops the size of the array off the stack and pushes a new array of the given type onto
            the stack.
            </summary>
            <param name="type"> The element type. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.LoadArrayElement(System.Type)">
            <summary>
            Pops the array and index off the stack and pushes the element value onto the stack.
            </summary>
            <param name="type"> The element type. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.StoreArrayElement(System.Type)">
            <summary>
            Pops the array, index and value off the stack and stores the value in the array.
            </summary>
            <param name="type"> The element type. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.LoadArrayLength">
            <summary>
            Pops an array off the stack and pushes the length of the array onto the stack.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.Throw">
            <summary>
            Pops an exception object off the stack and throws the exception.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.ReThrow">
            <summary>
            Re-throws the current exception.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.BegineExceptionBlock">
            <summary>
            Begins a try-catch-finally block.  After issuing this instruction any following
            instructions are conceptually within the try block.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.EndExceptionBlock">
            <summary>
            Ends a try-catch-finally block.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.BegineCatchBlock(System.Type)">
            <summary>
            Begins a catch block.  BeginExceptionBlock() must have already been called.
            </summary>
            <param name="exceptionType"> The type of exception to handle. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.BeginFinallyBlock">
            <summary>
            Begins a finally block.  BeginExceptionBlock() must have already been called.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.BeginFilterBlock">
            <summary>
            Begins a filter block.  BeginExceptionBlock() must have already been called.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.BeginFaultBlock">
            <summary>
            Begins a fault block.  BeginExceptionBlock() must have already been called.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.Leave(FluidScript.Compiler.Emit.ILLabel)">
            <summary>
            Unconditionally branches to the given label.  Unlike the regular branch instruction,
            this instruction can exit out of try, filter and catch blocks.
            </summary>
            <param name="label"> The label to branch to. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.EndFinally">
            <summary>
            This instruction can be used from within a finally block to resume the exception
            handling process.  It is the only valid way of leaving a finally block.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.EndFault">
            <summary>
            This instruction can be used from within a fault block to resume the exception
            handling process.  It is the only valid way of leaving a fault block.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.EndFilter">
            <summary>
            This instruction can be used from within a filter block to indicate whether the
            exception will be handled.  It pops an integer from the stack which should be <c>0</c>
            to continue searching for an exception handler or <c>1</c> to use the handler
            associated with the filter.  EndFilter() must be called at the end of a filter block.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.Breakpoint">
            <summary>
            Triggers a breakpoint in an attached debugger.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.MarkSequencePoint(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Marks a sequence point in the Microsoft intermediate language (MSIL) stream.
            </summary>
            <param name="document"> The document for which the sequence point is being defined. </param>
            <param name="startLine"> The line where the sequence point begins. </param>
            <param name="startColumn"> The column in the line where the sequence point begins. </param>
            <param name="endLine"> The line where the sequence point ends. </param>
            <param name="endColumn"> The column in the line where the sequence point ends. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ILGenerator.NoOperation">
            <summary>
            Does nothing.
            </summary>
        </member>
        <member name="T:FluidScript.Compiler.Emit.ILLabel">
            <summary>
            Represents a label in IL code.
            </summary>
        </member>
        <member name="T:FluidScript.Compiler.Emit.ILLocalVariable">
            <summary>
            Represents a local variable in CIL code.
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.Emit.ILLocalVariable.Index">
            <summary>
            Gets the zero-based index of the local variable within the method body.
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.Emit.ILLocalVariable.Type">
            <summary>
            Gets the type of the local variable.
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.Emit.ILLocalVariable.Name">
            <summary>
            Gets the local variable name, or <c>null</c> if a name was not provided.
            </summary>
        </member>
        <member name="T:FluidScript.Compiler.Emit.IMember">
            <summary>
            Member Generate
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.Emit.IMember.MemberInfo">
            <summary>
            Member Builder
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.LamdaGen.DefineAnonymousMethod(System.Type[],System.Type)">
            <summary>
            Define Anonymous class
            </summary>
            <param name="types">Ctor types</param>
            <param name="returnType">Return Type of Lamda</param>
            <returns>Type builder</returns>
        </member>
        <member name="T:FluidScript.Compiler.Emit.MethodBodyGenerator">
            <summary>
            Method body IL Generator
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.Emit.MethodBodyGenerator.SyntaxTree">
            <summary>
            Syntax Tree of method
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.MethodBodyGenerator.#ctor(FluidScript.Compiler.Emit.IMethodBase,System.Reflection.Emit.ILGenerator,System.Boolean)">
            <summary>
            Initializes new instance of <see cref="T:FluidScript.Compiler.Emit.MethodBodyGenerator"/>
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.Emit.MethodBodyGenerator.DebugDoument">
            <summary>
            Debug Document writter
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.Emit.MethodBodyGenerator.Source">
            <summary>
            Source code
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.MethodBodyGenerator.MarkSequencePoint(FluidScript.Compiler.Debugging.TextSpan)">
            <summary>
            Marks a sequence point in the Microsoft intermediate language (MSIL) stream.
            </summary>
            <param name="span"> The start and end positions which define the sequence point. </param>
        </member>
        <member name="P:FluidScript.Compiler.Emit.MethodBodyGenerator.FunctionName">
            <summary>
            Gets or sets the name of the function that is being generated.
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.Emit.MethodBodyGenerator.InsideTryCatchOrFinally">
            <summary>
            Indicates current IL is inside try catch or nor
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.MethodBodyGenerator.PushBreakOrContinueInfo(System.String[],FluidScript.Compiler.Emit.ILLabel,FluidScript.Compiler.Emit.ILLabel,System.Boolean)">
            <summary>
            Pushes information about break or continue targets to a stack.
            </summary>
            <param name="labels"> The label names associated with the break or continue target.
            Can be <c>null</c>. </param>
            <param name="breakTarget"> The IL label to jump to if a break statement is encountered. </param>
            <param name="continueTarget"> The IL label to jump to if a continue statement is
            encountered.  Can be <c>null</c>. </param>
            <param name="labelledOnly"> <c>true</c> if break or continue statements without a label
            should ignore this entry; <c>false</c> otherwise. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.MethodBodyGenerator.PopBreakOrContinueInfo">
            <summary>
            Removes the top-most break or continue information from the stack.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.MethodBodyGenerator.GetBreakTarget(System.String)">
            <summary>
            Returns the break target for the statement with the given label, if one is provided, or
            the top-most break target otherwise.
            </summary>
            <param name="labelName"> The label associated with the break target.  Can be
            <c>null</c>. </param>
            <returns> The break target for the statement with the given label. </returns>
        </member>
        <member name="M:FluidScript.Compiler.Emit.MethodBodyGenerator.GetContinueTarget(System.String)">
            <summary>
            Returns the continue target for the statement with the given label, if one is provided, or
            the top-most continue target otherwise.
            </summary>
            <param name="labelName"> The label associated with the continue target.  Can be
            <c>null</c>. </param>
            <returns> The continue target for the statement with the given label. </returns>
        </member>
        <member name="P:FluidScript.Compiler.Emit.MethodBodyGenerator.BreakOrContinueStackSize">
            <summary>
            Gets the number of available break or continue targets.  Used to support break or
            continue statements within finally blocks.
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.Emit.MethodBodyGenerator.LongJumpCallback">
            <summary>
            Gets or sets a delegate that is called when EmitLongJump() is called and the target
            label is outside the LongJumpStackSizeThreshold.
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.Emit.MethodBodyGenerator.LongJumpStackSizeThreshold">
            <summary>
            Gets or sets the depth of the break/continue stack at the start of the finally
            statement.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.MethodBodyGenerator.GetBreakOrContinueLabelDepth(FluidScript.Compiler.Emit.ILLabel)">
            <summary>
            Searches for the given label in the break/continue stack.
            </summary>
            <param name="label"></param>
            <returns> The depth of the label in the stack.  Zero indicates the bottom of the stack.
            <c>-1</c> is returned if the label was not found. </returns>
        </member>
        <member name="M:FluidScript.Compiler.Emit.MethodBodyGenerator.EmitLongJump(FluidScript.Compiler.Emit.ILGenerator,FluidScript.Compiler.Emit.ILLabel)">
            <summary>
            Long jump like retur,break,goto
            </summary>
            <param name="generator"></param>
            <param name="label"></param>
        </member>
        <member name="P:FluidScript.Compiler.Emit.MethodBodyGenerator.ReturnTarget">
            <summary>
            Gets or sets the label the return statement should jump to (with the return value on
            top of the stack).  Will be <c>null</c> if code is being generated outside a function
            context.
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.Emit.MethodBodyGenerator.ReturnVariable">
            <summary>
            Gets or sets the variable that holds the return value for the function.  Will be
            <c>null</c> if code is being generated outside a function context or if no return
            statements have been encountered.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.MethodBodyGenerator.DeclareVariable(System.Type,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.MethodBodyGenerator.GetLocalVariable(System.String)">
            <summary>
            Get Declared local variable
            </summary>
            Problem when scope
        </member>
        <member name="M:FluidScript.Compiler.Emit.MethodBodyGenerator.Compile">
            <summary>Creates IL Code</summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.MethodBodyGenerator.FluidScript#Compiler#IExpressionVisitor{FluidScript#Compiler#SyntaxTree#Expression}#VisitUnary(FluidScript.Compiler.SyntaxTree.UnaryExpression)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.MethodBodyGenerator.FluidScript#Compiler#IExpressionVisitor{FluidScript#Compiler#SyntaxTree#Expression}#VisitBinary(FluidScript.Compiler.SyntaxTree.BinaryExpression)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.MethodBodyGenerator.FluidScript#Compiler#IExpressionVisitor{FluidScript#Compiler#SyntaxTree#Expression}#VisitArrayLiteral(FluidScript.Compiler.SyntaxTree.ArrayListExpression)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.MethodBodyGenerator.FluidScript#Compiler#IExpressionVisitor{FluidScript#Compiler#SyntaxTree#Expression}#VisitAssignment(FluidScript.Compiler.SyntaxTree.AssignmentExpression)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.MethodBodyGenerator.FluidScript#Compiler#IExpressionVisitor{FluidScript#Compiler#SyntaxTree#Expression}#VisitMember(FluidScript.Compiler.SyntaxTree.MemberExpression)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.MethodBodyGenerator.FluidScript#Compiler#IExpressionVisitor{FluidScript#Compiler#SyntaxTree#Expression}#VisitCall(FluidScript.Compiler.SyntaxTree.InvocationExpression)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.MethodBodyGenerator.FluidScript#Compiler#IExpressionVisitor{FluidScript#Compiler#SyntaxTree#Expression}#VisitLiteral(FluidScript.Compiler.SyntaxTree.LiteralExpression)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.MethodBodyGenerator.FluidScript#Compiler#IExpressionVisitor{FluidScript#Compiler#SyntaxTree#Expression}#VisitTernary(FluidScript.Compiler.SyntaxTree.TernaryExpression)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.MethodBodyGenerator.FluidScript#Compiler#IExpressionVisitor{FluidScript#Compiler#SyntaxTree#Expression}#VisitInstanceOf(FluidScript.Compiler.SyntaxTree.InstanceOfExpression)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.MethodBodyGenerator.FluidScript#Compiler#IExpressionVisitor{FluidScript#Compiler#SyntaxTree#Expression}#VisitNew(FluidScript.Compiler.SyntaxTree.NewExpression)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.MethodBodyGenerator.FluidScript#Compiler#IExpressionVisitor{FluidScript#Compiler#SyntaxTree#Expression}#VisitMember(FluidScript.Compiler.SyntaxTree.NameExpression)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.MethodBodyGenerator.FluidScript#Compiler#IExpressionVisitor{FluidScript#Compiler#SyntaxTree#Expression}#VisitThis(FluidScript.Compiler.SyntaxTree.ThisExpression)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.MethodBodyGenerator.FluidScript#Compiler#IExpressionVisitor{FluidScript#Compiler#SyntaxTree#Expression}#VisitSuper(FluidScript.Compiler.SyntaxTree.SuperExpression)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.MethodBodyGenerator.FluidScript#Compiler#IExpressionVisitor{FluidScript#Compiler#SyntaxTree#Expression}#VisitIndex(FluidScript.Compiler.SyntaxTree.IndexExpression)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.MethodBodyGenerator.FluidScript#Compiler#IExpressionVisitor{FluidScript#Compiler#SyntaxTree#Expression}#VisitDeclaration(FluidScript.Compiler.SyntaxTree.VariableDeclarationExpression)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.MethodBodyGenerator.FluidScript#Compiler#IExpressionVisitor{FluidScript#Compiler#SyntaxTree#Expression}#VisitNull(FluidScript.Compiler.SyntaxTree.NullExpression)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.MethodBodyGenerator.FluidScript#Compiler#IExpressionVisitor{FluidScript#Compiler#SyntaxTree#Expression}#VisitNullPropegator(FluidScript.Compiler.SyntaxTree.NullPropegatorExpression)">
            <inheritdoc/>
        </member>
        <member name="F:FluidScript.Compiler.Emit.MethodCompileOption.Dupplicate">
            <summary>
            Need to duplicate the copy of the value to the stack
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.Emit.MethodCompileOption.Return">
            <summary>
            currently Returning the value
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.Emit.MethodCompileOption.HasThis">
            <summary>
            Calling Argument has this
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.Emit.MethodCompileOption.EmitStartAddress">
            <summary>
            Emit address of start
            </summary>
        </member>
        <member name="T:FluidScript.Compiler.Emit.ParameterInfo">
            <summary>
            Emit Parameter
            </summary>
            Todo: Default value for parameter
        </member>
        <member name="T:FluidScript.Compiler.Emit.ReflectionILGenerator">
            <summary>
            Reflection IL Generator
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.Emit.ReflectionILGenerator.Generator">
            <summary>
            Underlying ILGenerator
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.Emit.ReflectionILGenerator.EmitDebugInfo">
            <summary>
            Indicated whether to emit debug info
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.#ctor(System.Reflection.Emit.ILGenerator,System.Boolean)">
            <summary>
            New Reflection ILGenerator
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.Add">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.BegineCatchBlock(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.BegineExceptionBlock">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.BeginFaultBlock">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.BeginFilterBlock">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.BeginFinallyBlock">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.BitwiseAnd">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.BitwiseNot">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.BitwiseOr">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.BitwiseXor">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.Box(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.Branch(FluidScript.Compiler.Emit.ILLabel)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.BranchIfEqual(FluidScript.Compiler.Emit.ILLabel)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.BranchIfGreaterThan(FluidScript.Compiler.Emit.ILLabel)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.BranchIfGreaterThanOrEqual(FluidScript.Compiler.Emit.ILLabel)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.BranchIfGreaterThanOrEqualUnsigned(FluidScript.Compiler.Emit.ILLabel)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.BranchIfGreaterThanUnsigned(FluidScript.Compiler.Emit.ILLabel)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.BranchIfLessThan(FluidScript.Compiler.Emit.ILLabel)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.BranchIfLessThanOrEqual(FluidScript.Compiler.Emit.ILLabel)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.BranchIfLessThanOrEqualUnsigned(FluidScript.Compiler.Emit.ILLabel)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.BranchIfLessThanUnsigned(FluidScript.Compiler.Emit.ILLabel)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.BranchIfNotEqual(FluidScript.Compiler.Emit.ILLabel)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.BranchIfNotZero(FluidScript.Compiler.Emit.ILLabel)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.BranchIfZero(FluidScript.Compiler.Emit.ILLabel)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.Breakpoint">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.CallStatic(System.Reflection.MethodBase)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.CallVirtual(System.Reflection.MethodBase)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.CastClass(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.CompareEqual">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.CompareGreaterThan">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.CompareGreaterThanUnsigned">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.CompareLessThan">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.CompareLessThanUnsigned">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.Complete">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.ConvertToBool">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.ConvertToByte">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.ConvertToChar">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.ConvertToDouble">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.ConvertToInt16">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.ConvertToInt32">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.ConvertToInt64">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.ConvertToSingle">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.ConvertToUnsignedByte">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.ConvertToUnsignedInt16">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.ConvertToUnsignedInt32">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.ConvertToUnsignedInt64">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.CreateLabel">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.DeclareVariable(System.Type,System.String,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.DefineLabelPosition(FluidScript.Compiler.Emit.ILLabel)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.Divide">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.Duplicate">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.EndExceptionBlock">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.EndFilter">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.EndFinally">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.InitObject(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.IsInstance(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.Leave(FluidScript.Compiler.Emit.ILLabel)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.LoadAddressOfVariable(FluidScript.Compiler.Emit.ILLocalVariable)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.LoadArgument(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.LoadAddressOfArgument(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.LoadArrayElement(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.LoadArrayLength">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.LoadBool(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.LoadByte(System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.LoadByte(System.SByte)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.LoadChar(System.Char)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.LoadDouble(System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.LoadField(System.Reflection.FieldInfo)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.LoadInt16(System.Int16)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.LoadInt16(System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.LoadInt32(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.LoadInt32(System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.LoadInt64(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.LoadInt64(System.UInt64)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.LoadNull">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.LoadSingle(System.Single)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.LoadStaticMethodPointer(System.Reflection.MethodBase)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.LoadString(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.LoadToken(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.LoadToken(System.Reflection.MethodBase)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.LoadToken(System.Reflection.FieldInfo)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.LoadVariable(FluidScript.Compiler.Emit.ILLocalVariable)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.LoadVirtualMethodPointer(System.Reflection.MethodBase)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.MarkSequencePoint(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.MarkSequencePoint(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,FluidScript.Compiler.Debugging.TextSpan)">
            <summary>
            Marks a sequence point in the Microsoft intermediate language (MSIL) stream.
            </summary>
            <param name="document"> The document for which the sequence point is being defined. </param>
            <param name="span"> The start and end positions which define the sequence point. </param>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.Multiply">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.Negate">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.NewArray(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.NewObject(System.Reflection.ConstructorInfo)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.NoOperation">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.Pop">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.Remainder">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.ReThrow">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.Return">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.ShiftLeft">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.ShiftRight">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.ShiftRightUnsigned">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.StoreArgument(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.StoreArrayElement(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.StoreField(System.Reflection.FieldInfo)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.StoreVariable(FluidScript.Compiler.Emit.ILLocalVariable)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.Subtract">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.Switch(FluidScript.Compiler.Emit.ILLabel[])">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.Throw">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.Unbox(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Emit.ReflectionILGenerator.UnboxObject(System.Type)">
            <inheritdoc/>
        </member>
        <member name="T:FluidScript.Compiler.Emit.TypeName">
            <summary>
            Full Type Name
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.Generators.TypeGenerator.MemberInfo">
            <summary>
            MemberType of Generator
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.Generators.TypeGenerator.Assembly">
            <inheritdoc/>
        </member>
        <member name="P:FluidScript.Compiler.Generators.TypeGenerator.AssemblyQualifiedName">
            <inheritdoc/>
        </member>
        <member name="P:FluidScript.Compiler.Generators.TypeGenerator.FullName">
            <inheritdoc/>
        </member>
        <member name="P:FluidScript.Compiler.Generators.TypeGenerator.GUID">
            <inheritdoc/>
        </member>
        <member name="P:FluidScript.Compiler.Generators.TypeGenerator.Namespace">
            <inheritdoc/>
        </member>
        <member name="P:FluidScript.Compiler.Generators.TypeGenerator.UnderlyingSystemType">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Generators.TypeGenerator.CheckImplementMethod(System.String,System.Type[],System.String@,System.Type@,System.Reflection.MethodAttributes@)">
            <summary>
            Checks whether a method can be implemented or not
            </summary>
            <param name="name">Origincal name</param>
            <param name="types">Types</param>
            <param name="newName">New name of implemented method</param>
            <param name="returnType">Return type for the implemented method</param>
            <param name="attrs">Method attributes</param>
            <returns></returns>
        </member>
        <member name="M:FluidScript.Compiler.Generators.TypeGenerator.GetAttributeFlagsImpl">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Generators.TypeGenerator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Generators.TypeGenerator.GetConstructors(System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Generators.TypeGenerator.GetElementType">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Generators.TypeGenerator.GetEvent(System.String,System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Generators.TypeGenerator.GetEvents(System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Generators.TypeGenerator.GetField(System.String,System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Generators.TypeGenerator.GetFields(System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Generators.TypeGenerator.GetInterface(System.String,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Generators.TypeGenerator.GetInterfaces">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Generators.TypeGenerator.GetMembers(System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Generators.TypeGenerator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Generators.TypeGenerator.GetMethods(System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Generators.TypeGenerator.GetMember(System.String,System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Generators.TypeGenerator.GetNestedType(System.String,System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Generators.TypeGenerator.GetNestedTypes(System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Generators.TypeGenerator.GetProperties(System.Reflection.BindingFlags)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Generators.TypeGenerator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Generators.TypeGenerator.HasElementTypeImpl">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Generators.TypeGenerator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Generators.TypeGenerator.IsArrayImpl">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Generators.TypeGenerator.IsByRefImpl">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Generators.TypeGenerator.IsCOMObjectImpl">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Generators.TypeGenerator.IsPointerImpl">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Generators.TypeGenerator.IsPrimitiveImpl">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Generators.TypeGenerator.GetCustomAttributes(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Generators.TypeGenerator.GetCustomAttributes(System.Type,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.Generators.TypeGenerator.IsDefined(System.Type,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.ITypeContext.GetType(FluidScript.Compiler.Emit.TypeName)">
            <summary>
            Get resolved <see cref="T:System.Type"/>
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.Lexer.TokenType.Parenthesized">
            <summary>
            ()
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.Lexer.TokenType.AnonymousMethod">
            <summary>
            =>
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.Lexer.TokenType.LeftBracket">
            <summary>
            [
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.Lexer.TokenType.LeftParenthesis">
            <summary>
            (
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.Lexer.TokenType.RightParenthesis">
            <summary>
            )
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.Lexer.TokenType.LeftBrace">
            <summary>
            {
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.Lexer.TokenType.RightBrace">
            <summary>
            }
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.Lexer.TokenType.Circumflex">
             <summary>
            ^
             </summary>
        </member>
        <member name="F:FluidScript.Compiler.Lexer.TokenType.StarStar">
            <summary>
            ** for pow
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.Lexer.TokenType.Bang">
            <summary>
            !
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.Lexer.TokenType.PlusPlus">
            <summary>
            ++
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.Lexer.TokenType.MinusMinus">
            <summary>
            --
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.Lexer.TokenType.PlusEqual">
            +=
        </member>
        <member name="F:FluidScript.Compiler.Lexer.TokenType.MinusEqual">
            -=
        </member>
        <member name="F:FluidScript.Compiler.Lexer.TokenType.BackSlash">
            <summary>
            /
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.Lexer.TokenType.ForwardSlash">
            <summary>
            \
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.Parser.Source">
            <summary>
            Source text
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.Parser.TokenType">
            <summary>
            Token type
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.Parser.Settings">
            <summary>
            Parse settings
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Parser.#ctor(FluidScript.Compiler.ITextSource,FluidScript.Compiler.ParserSettings)">
            <summary>
            Initializes new <see cref="T:FluidScript.Compiler.ScriptParser"/>
            </summary>
            <param name="source"></param>
            <param name="settings"></param>
        </member>
        <member name="P:FluidScript.Compiler.Parser.CurrentLabels">
            <summary>
            labels like start: and goto start
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.Parser.Current">
            <summary>
            Current Token
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Parser.MoveNext(System.Boolean)">
            <summary>
            Move to next <see cref="F:FluidScript.Compiler.Parser.TokenType"/>
            </summary>
            <param name="skipLine">Indicates line to be skipped</param>
        </member>
        <member name="M:FluidScript.Compiler.Parser.Reset">
            <summary>
            Reset source position
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Parser.GetTokenType(System.Boolean)">
            <summary>
            Token type
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Parser.GetStatement">
            <summary>
            Creates <see cref="T:FluidScript.Compiler.SyntaxTree.Statement"/> for <see cref="F:FluidScript.Compiler.Parser.Source"/>
            </summary>
            <returns>Parse <see cref="T:FluidScript.Compiler.SyntaxTree.Statement"/></returns>
        </member>
        <member name="M:FluidScript.Compiler.Parser.GetExpression">
            <summary>
            Creates <see cref="T:FluidScript.Compiler.SyntaxTree.Expression"/> for <see cref="F:FluidScript.Compiler.Parser.Source"/>
            </summary>
            <returns>Parse <see cref="T:FluidScript.Compiler.SyntaxTree.Expression"/></returns>
        </member>
        <member name="M:FluidScript.Compiler.Parser.VisitStatement">
            <summary>
            Statement 
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Parser.VisitForStatement">
            <summary>
            Loop Statement for 
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Parser.VisitWhileStatement">
            <summary>
            Loop Statement while
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Parser.VisitDoWhileStatement">
            <summary>
            Loop Statement do while
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Parser.VisitIfStatement">
            <summary>
            Visit if statement
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluidScript.Compiler.Parser.VisitLocalFunction">
            <summary>
            Visit local function
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluidScript.Compiler.Parser.VisitBlock">
            <summary>
            Visit block {}
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Parser.VisitPostfixExpression">
            <summary>
            Postfix Expression
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Parser.VisitLeftHandSideExpression">
            <summary>
            Left side of expression
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Parser.VisitRightExpression(FluidScript.Compiler.SyntaxTree.Expression)">
            <summary>
            Visit right side of expression
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Parser.VisitIdentifier">
            <summary>
            Identifier expression like name, this, new etc
            </summary>
            <returns><see cref="T:FluidScript.Compiler.SyntaxTree.NameExpression"/></returns>
        </member>
        <member name="M:FluidScript.Compiler.Parser.VisitArrayLiteral">
            <summary>
            format [1,2]&lt;int&gt;(size) or [1,2]&lt;int&gt;
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluidScript.Compiler.Parser.VisitLamdaExpression">
            <summary>
            Visit lamda expression ex:lamda()=>1;
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Parser.VisitArgumentList(FluidScript.Compiler.Lexer.TokenType,FluidScript.Compiler.Lexer.TokenType)">
            <summary>
            Don't Forget to Call ToArray
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluidScript.Compiler.Parser.VisitExpressionList(FluidScript.Compiler.Lexer.TokenType,FluidScript.Compiler.Lexer.TokenType)">
            <summary>
            Don't Forget to Call ToArray
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluidScript.Compiler.Parser.VisitFunctionParameters">
            <summary>
            Dont Forget to Call ToArray x:int
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluidScript.Compiler.Parser.VisitType">
            <summary>
            Visit type name
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Parser.VisitArrayRanks">
            <summary>
            Visit Array indexes
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Parser.Skip(System.Int32)">
            <summary>
            Skip tokens
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Parser.Take(System.Int32)">
            <summary>
            Take specified chars
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Parser.VisitAnonymousObjectMembers">
            <summary>
            {x:1, add()=> {}}
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluidScript.Compiler.Parser.VisitVarDeclarations">
            <summary>
            Visit local variable declaration
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.Parser.GetStatement(System.String,FluidScript.Compiler.ParserSettings)">
            <summary>
            Creates <see cref="T:FluidScript.Compiler.SyntaxTree.Statement"/> for <paramref name="text"/>
            </summary>
            <param name="text">Text to parse</param>
            <param name="settings">Parser options if null will be default options</param>
            <returns>Parse <see cref="T:FluidScript.Compiler.SyntaxTree.Statement"/></returns>
        </member>
        <member name="M:FluidScript.Compiler.Parser.GetExpression(System.String,FluidScript.Compiler.ParserSettings)">
            <summary>
            Creates <see cref="T:FluidScript.Compiler.SyntaxTree.Expression"/> for <paramref name="text"/>
            </summary>
            <param name="text">Text to parse</param>
            <param name="settings">Parser options if null will be default options</param>
            <returns>Parse <see cref="T:FluidScript.Compiler.SyntaxTree.Expression"/></returns>
        </member>
        <member name="T:FluidScript.Compiler.RuntimeCompiler">
            <summary>
            Runtime evaluation of Syntax tree with <see cref="P:FluidScript.Compiler.RuntimeCompiler.Locals"/>
            <list type="bullet">it will be not same as compiled </list>
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.RuntimeCompiler.#ctor">
            <summary>
            New runtime evaluation with <see cref="T:FluidScript.GlobalObject"/> target
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.RuntimeCompiler.#ctor(System.Object)">
            <summary>
            New runtime evaluation 
            </summary>
            <param name="target">Global target for execution</param>
        </member>
        <member name="M:FluidScript.Compiler.RuntimeCompiler.#ctor(System.Object,FluidScript.Compiler.RuntimeVariables)">
            <summary>
            New runtime evaluation with local values
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.RuntimeCompiler.Item(System.String)">
            <summary>
            Gets or Sets value for execution
            </summary>
            <param name="name">Name to store</param>
            <returns>value stored in it</returns>
        </member>
        <member name="M:FluidScript.Compiler.RuntimeCompiler.Invoke(FluidScript.Compiler.SyntaxTree.Statement,System.Object)">
            <summary>
            Evaluate the <paramref name="statement"/>
            </summary>
            <exception cref="T:System.IndexOutOfRangeException"/>
            <exception cref="T:System.NullReferenceException"/>
            <exception cref="T:System.MissingMethodException"/>
        </member>
        <member name="M:FluidScript.Compiler.RuntimeCompiler.Invoke(FluidScript.Compiler.SyntaxTree.Expression,System.Object)">
            <summary>
            Evaluate the <paramref name="expression"/>
            </summary>
            <exception cref="T:System.IndexOutOfRangeException"/>
            <exception cref="T:System.NullReferenceException"/>
            <exception cref="T:System.MissingMethodException"/>
        </member>
        <member name="M:FluidScript.Compiler.RuntimeCompiler.EnterScope">
            <summary>
            create's a scope for variables inside a block
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.RuntimeCompiler.VisitAssignment(FluidScript.Compiler.SyntaxTree.AssignmentExpression)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.RuntimeCompiler.ResolveCall(FluidScript.Compiler.SyntaxTree.InvocationExpression,System.Object[])">
            <summary>
            Get method
            </summary>
            <returns>target to invoke</returns>
        </member>
        <member name="M:FluidScript.Compiler.RuntimeCompiler.VisitMember(FluidScript.Compiler.SyntaxTree.MemberExpression)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.RuntimeCompiler.VisitMember(FluidScript.Compiler.SyntaxTree.NameExpression)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.RuntimeCompiler.FluidScript#Compiler#IStatementVisitor#VisitExpression(FluidScript.Compiler.SyntaxTree.ExpressionStatement)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.RuntimeCompiler.VisitDeclaration(FluidScript.Compiler.SyntaxTree.VariableDeclarationExpression)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.RuntimeCompiler.FluidScript#Compiler#IStatementVisitor#VisitReturn(FluidScript.Compiler.SyntaxTree.ReturnOrThrowStatement)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.RuntimeCompiler.FluidScript#Compiler#IStatementVisitor#VisitBlock(FluidScript.Compiler.SyntaxTree.BlockStatement)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.RuntimeCompiler.FluidScript#Compiler#IStatementVisitor#VisitDeclaration(FluidScript.Compiler.SyntaxTree.LocalDeclarationStatement)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.RuntimeCompiler.FluidScript#Compiler#IStatementVisitor#VisitLoop(FluidScript.Compiler.SyntaxTree.LoopStatement)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.RuntimeCompiler.FluidScript#Compiler#IStatementVisitor#VisitIf(FluidScript.Compiler.SyntaxTree.IfStatement)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.RuntimeCompiler.FluidScript#Compiler#IStatementVisitor#VisitBreak(FluidScript.Compiler.SyntaxTree.BreakStatement)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.RuntimeCompiler.FluidScript#Compiler#IStatementVisitor#VisitContinue(FluidScript.Compiler.SyntaxTree.ContinueStatement)">
            <inheritdoc/>
        </member>
        <member name="T:FluidScript.Compiler.RuntimeCompiler.BranchContext">
            <summary>
            for long jump or break and continue
            </summary>
        </member>
        <member name="T:FluidScript.Compiler.RuntimeVariables">
            <summary>
            Provides local variables for runtime
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.RuntimeVariables.TryFindVariable(System.String,FluidScript.Runtime.LocalVariable@)">
            <summary>
            Get variable in the scope
            </summary>
        </member>
        <member name="T:FluidScript.Compiler.ScriptCompiler">
            <summary>
            Evaluates an <see cref="T:FluidScript.Compiler.SyntaxTree.Expression"/> using reflection
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.ScriptCompiler.VisitMember(FluidScript.Compiler.SyntaxTree.MemberExpression)">
            Member Visit
        </member>
        <member name="T:FluidScript.Compiler.ScriptParser">
            <summary>
            Syntax Visiitor which will tokenizes the text
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.ScriptParser.modifiers">
            <summary>
            current modifiers
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.ScriptParser.VisitMember">
            <summary>
            Visit member declaration
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.ScriptParser.VisitMembers">
            <summary>
            Visit members declaration
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.ScriptParser.VisitTypeDeclaration">
            <summary>
            Type declaration
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.ScriptParser.VisitFieldDeclaration">
            <summary>
            Field declaration
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.ScriptParser.VisitFunctionDeclaration">
            <summary>
            Function Declartion
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.ScriptParser.ParseText(System.String,FluidScript.Compiler.ParserSettings)">
            <summary>
            Creates <see cref="T:FluidScript.Compiler.SyntaxTree.Node"/> for <paramref name="text"/>
            </summary>
            <param name="text">Text to parse</param>
            <param name="settings">Parser options if null will be default options</param>
            <returns>Parsed <see cref="T:FluidScript.Compiler.SyntaxTree.Node"/></returns>
        </member>
        <member name="M:FluidScript.Compiler.ScriptParser.ParseProgram(System.String,FluidScript.Compiler.ParserSettings)">
            <summary>
            Creates <see cref="T:FluidScript.Compiler.SyntaxTree.Node"/> for file <paramref name="path"/>
            </summary>
            <param name="path">Text to parse</param>
            <param name="settings">Parser options if null will be default options</param>
            <returns>Parsed <see cref="T:FluidScript.Compiler.SyntaxTree.Node"/></returns>
        </member>
        <member name="T:FluidScript.Compiler.SyntaxTree.Expression">
            <summary>
            Base Expression
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.SyntaxTree.Expression.Empty">
            <summary>
            Empty Expression
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.Expression.Accept``1(FluidScript.Compiler.IExpressionVisitor{``0})">
            <summary>
            Optimizes expression for emit or others
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="visitor"></param>
            <returns></returns>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.Expression.GenerateCode(FluidScript.Compiler.Emit.MethodBodyGenerator,FluidScript.Compiler.Emit.MethodCompileOption)">
            <summary>
            Generates IL code for <see cref="T:FluidScript.Compiler.SyntaxTree.Expression"/>
            </summary>
            <param name="generator"></param>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.Expression.Custom(System.Action{FluidScript.Compiler.SyntaxTree.Expression,FluidScript.Compiler.Emit.MethodBodyGenerator})">
            <summary>
            Custom IL Generation
            </summary>
        </member>
        <member name="T:FluidScript.Compiler.SyntaxTree.ArrayListExpression">
            <summary>
            Array literal &lt;<see cref="F:FluidScript.Compiler.SyntaxTree.ArrayListExpression.ArrayType"/>&gt;[1,2]
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.SyntaxTree.ArrayListExpression.Expressions">
            <summary>
            List of array items
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.SyntaxTree.ArrayListExpression.Arguments">
            <summary>
            Array Size
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.SyntaxTree.ArrayListExpression.ArrayType">
            <summary>
            Array type
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.ArrayListExpression.#ctor(FluidScript.Compiler.SyntaxTree.INodeList{FluidScript.Compiler.SyntaxTree.Expression},FluidScript.Compiler.SyntaxTree.TypeSyntax,FluidScript.Compiler.SyntaxTree.INodeList{FluidScript.Compiler.SyntaxTree.Expression})">
            <summary>
            Initializes new <see cref="T:FluidScript.Compiler.SyntaxTree.ArrayListExpression"/>
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.ArrayListExpression.Accept``1(FluidScript.Compiler.IExpressionVisitor{``0})">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.ArrayListExpression.GenerateCode(FluidScript.Compiler.Emit.MethodBodyGenerator,FluidScript.Compiler.Emit.MethodCompileOption)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.ArrayListExpression.ToString">
            <inheritdoc/>
        </member>
        <member name="P:FluidScript.Compiler.SyntaxTree.BinaryExpression.Conversions">
            <summary>
            Argument convert list
            </summary>
        </member>
        <member name="T:FluidScript.Compiler.SyntaxTree.ConvertExpression">
            <summary>
            &lt;type&gt;(Expression)
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.SyntaxTree.ConvertExpression.Method">
            <summary>
            Conversion method
            </summary>
        </member>
        <member name="T:FluidScript.Compiler.SyntaxTree.IndexExpression">
            <summary>
            Indexer value[exps]
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.SyntaxTree.IndexExpression.Conversions">
            <summary>
            Argument convert list
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.SyntaxTree.InvocationExpression.Conversions">
            <summary>
            Argument convert list
            </summary>
        </member>
        <member name="T:FluidScript.Compiler.SyntaxTree.LiteralExpression">
            <summary>
            Literal expression
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.SyntaxTree.LiteralExpression.Value">
            <summary>
            Literal valie
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.LiteralExpression.#ctor(System.Object)">
            <summary>
            Initializes new <see cref="T:FluidScript.Compiler.SyntaxTree.LiteralExpression"/>
            </summary>
            <param name="value"></param>
        </member>
        <member name="P:FluidScript.Compiler.SyntaxTree.LiteralExpression.ReflectedValue">
            <summary>
            Reflected Value of <see cref="F:FluidScript.Compiler.SyntaxTree.LiteralExpression.Value"/>
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.LiteralExpression.Accept``1(FluidScript.Compiler.IExpressionVisitor{``0})">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.LiteralExpression.GenerateCode(FluidScript.Compiler.Emit.MethodBodyGenerator,FluidScript.Compiler.Emit.MethodCompileOption)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.LiteralExpression.ToString">
            <inheritdoc/>
        </member>
        <member name="T:FluidScript.Compiler.SyntaxTree.MemberExpression">
            <summary>
            Member access expression
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.SyntaxTree.MemberExpression.Binder">
            <summary>
            Compiler generation binder
            </summary>
        </member>
        <member name="T:FluidScript.Compiler.SyntaxTree.NameExpression">
            <summary>
            Identfier Expression
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.SyntaxTree.NameExpression.Name">
            <summary>
            Name of the Identifier
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.SyntaxTree.NameExpression.Binder">
            <summary>
            Binding for compiler generation
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.SyntaxTree.NameExpression.Target">
            <summary>
            Target object 
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.NameExpression.#ctor(System.String,FluidScript.Compiler.SyntaxTree.ExpressionType)">
            <summary>
            Creates Identifier Expression
            </summary>
            <param name="name">Name of the Identifier</param>
            <param name="expType">Expression type</param>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.NameExpression.ToString">
            <summary>
            String Value
            </summary>
            <returns>string</returns>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.NameExpression.Accept``1(FluidScript.Compiler.IExpressionVisitor{``0})">
            <summary>
            Optimizes or evaluate the expression
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.NameExpression.GenerateCode(FluidScript.Compiler.Emit.MethodBodyGenerator,FluidScript.Compiler.Emit.MethodCompileOption)">
            <summary>
            Generate Compiled code
            </summary>
            <param name="generator"></param>
        </member>
        <member name="T:FluidScript.Compiler.SyntaxTree.NullExpression">
            <summary>
            Null Expression
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.SystemLiternalExpression.GenerateCode(FluidScript.Compiler.Emit.MethodBodyGenerator,FluidScript.Compiler.Emit.MethodCompileOption)">
            <inheritdoc/>
        </member>
        <member name="P:FluidScript.Compiler.SyntaxTree.UnaryExpression.Method">
            <summary>
            Operator overload method
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.SyntaxTree.UnaryExpression.MethodName">
            <summary>
            Get the unary operator method name
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.SyntaxTree.UnaryExpression.Conversions">
            <summary>
            Type conversion of arguments
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.VariableDeclarationExpression.Accept``1(FluidScript.Compiler.IExpressionVisitor{``0})">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.VariableDeclarationExpression.GenerateCode(FluidScript.Compiler.Emit.MethodBodyGenerator,FluidScript.Compiler.Emit.MethodCompileOption)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.VariableDeclarationExpression.ToString">
            <inheritdoc/>
        </member>
        <member name="F:FluidScript.Compiler.SyntaxTree.ExpressionType.Invocation">
            <summary>
            method call
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.SyntaxTree.ExpressionType.MemberAccess">
            <summary>
            .
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.SyntaxTree.ExpressionType.Block">
            <summary>
            array block initailization
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.SyntaxTree.ExpressionType.Circumflex">
            <summary>
            ^
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.SyntaxTree.ExpressionType.StarStar">
            <summary>
            <code>**</code>
            <see cref="F:FluidScript.Compiler.Lexer.TokenType.StarStar"/>
            </summary>
        </member>
        <member name="T:FluidScript.Compiler.SyntaxTree.Node">
            <summary>
            Abstract node for all syntax tree
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.Node.#ctor">
            <summary>
            Creates new <see cref="T:FluidScript.Compiler.SyntaxTree.Node"/>
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.Node.ChildNodes">
            <summary>
            Child node iterator
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.Node.ContainsNodeOfType``1">
            <summary>
            Contains a specified node <typeparamref name="T"/>
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.Node.Childs(FluidScript.Compiler.SyntaxTree.Node[])">
            <summary>
            Makes child nodes
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.NodeList`1.CopyTo(System.Array,System.Int32)">
            <summary>
            Copy to array starts from <paramref name="index"/>
            </summary>
        </member>
        <member name="T:FluidScript.Compiler.SyntaxTree.NodeList`1.Enumerator">
            <summary>
            Enumerates the elements of a <see cref="T:FluidScript.Compiler.SyntaxTree.NodeList`1"/>.
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.SyntaxTree.NodeList`1.Enumerator.Current">
            <summary>
            Gets the element at the current position of the enumerator.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.NodeList`1.Enumerator.Dispose">
            <summary>
            Releases all resources used by the <see cref="T:System.Collections.Generic.List`1"/>.Enumerator.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.NodeList`1.Enumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the <see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if
            the enumerator has passed the end of the collection.
            </returns>
        </member>
        <member name="T:FluidScript.Compiler.SyntaxTree.Statement">
            <summary>
            Statement like declarion, return etc
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.SyntaxTree.Statement.Labels">
            <summary>
            Labels associated with the statement
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.Statement.#ctor(FluidScript.Compiler.SyntaxTree.StatementType)">
            <summary>
            Initializes new <see cref="T:FluidScript.Compiler.SyntaxTree.Statement"/>
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.Statement.#ctor(System.String[],FluidScript.Compiler.SyntaxTree.StatementType)">
            <summary>
            Initializes new <see cref="T:FluidScript.Compiler.SyntaxTree.Statement"/>
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.SyntaxTree.Statement.Span">
            <summary>
            Statement Position
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.SyntaxTree.Statement.NodeType">
            <summary>
            Node Type
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.SyntaxTree.Statement.HasLabels">
            <summary>
            Indicates whether statement has any label
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.Statement.Accept(FluidScript.Compiler.IStatementVisitor)">
            <summary>
            Optimizes or evaluetes <see cref="T:FluidScript.Compiler.SyntaxTree.Statement"/>
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.Statement.GenerateCode(FluidScript.Compiler.Emit.MethodBodyGenerator)">
            <summary>
            Creates IL code 
            </summary>
            <param name="generator">The generator to output the CIL to.</param>
        </member>
        <member name="T:FluidScript.Compiler.SyntaxTree.Statement.StatementLocals">
            <summary>
            Statement Locals
            </summary>
            
        </member>
        <member name="F:FluidScript.Compiler.SyntaxTree.Statement.StatementLocals.NonDefaultBreakStatementBehavior">
            <summary>
            Gets or sets a value that indicates whether the break statement will be handled
            specially by the calling code - this means that GenerateStartOfStatement() and
            GenerateEndOfStatement() do not have to generate code to handle the break
            statement.
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.SyntaxTree.Statement.StatementLocals.NonDefaultSourceSpanBehavior">
            <summary>
            Gets or sets a value that indicates whether the debugging information will be
            handled specially by the calling code - this means that GenerateStartOfStatement()
            and GenerateEndOfStatement() do not have to set this information.
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.SyntaxTree.Statement.StatementLocals.EndOfStatement">
            <summary>
            Gets or sets a label marking the end of the statement.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.Statement.GenerateStartOfStatement(FluidScript.Compiler.Emit.MethodBodyGenerator,FluidScript.Compiler.SyntaxTree.Statement.StatementLocals)">
            <summary>
            Generates CIL for the start of every statement.
            </summary>
            <param name="generator">The generator to output the CIL to. </param>
            <param name="locals"> Variables common to both GenerateStartOfStatement() and GenerateEndOfStatement(). </param>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.Statement.GenerateEndOfStatement(FluidScript.Compiler.Emit.MethodBodyGenerator,FluidScript.Compiler.SyntaxTree.Statement.StatementLocals)">
            <summary>
            Generates CIL for the end of every statement.
            </summary>
            <param name="generator"> The generator to output the CIL to. </param>
            <param name="locals"> Variables common to both GenerateStartOfStatement() and GenerateEndOfStatement(). </param>
        </member>
        <member name="T:FluidScript.Compiler.SyntaxTree.BlockStatement">
            <summary>
            Block statement {}
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.SyntaxTree.BlockStatement.Statements">
            <summary>
            List of statements
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.BlockStatement.#ctor(FluidScript.Compiler.SyntaxTree.NodeList{FluidScript.Compiler.SyntaxTree.Statement},System.String[])">
            <summary>
            Initializes new <see cref="T:FluidScript.Compiler.SyntaxTree.BlockStatement"/>
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.BlockStatement.ChildNodes">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.BlockStatement.Accept(FluidScript.Compiler.IStatementVisitor)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.BlockStatement.GenerateCode(FluidScript.Compiler.Emit.MethodBodyGenerator)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.BlockStatement.ToString">
            <inheritdoc/>
        </member>
        <member name="T:FluidScript.Compiler.SyntaxTree.BreakStatement">
            <summary>
            Represents a break statement.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.BreakStatement.#ctor">
            <summary>
            Creates a new BreakStatement instance.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.BreakStatement.Accept(FluidScript.Compiler.IStatementVisitor)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.BreakStatement.GenerateCode(FluidScript.Compiler.Emit.MethodBodyGenerator)">
            <inheritdoc/>
        </member>
        <member name="T:FluidScript.Compiler.SyntaxTree.ContinueStatement">
            <summary>
            Represents a continue statement.
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.SyntaxTree.ContinueStatement.Label">
            <summary>
            Gets or sets the name of the label that identifies the loop to continue.  Can be <c>null</c>
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.ContinueStatement.#ctor(System.String)">
            <summary>
            Creates a new ContinueStatement instance.
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.ContinueStatement.Accept(FluidScript.Compiler.IStatementVisitor)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.ContinueStatement.GenerateCode(FluidScript.Compiler.Emit.MethodBodyGenerator)">
            <inheritdoc/>
        </member>
        <member name="T:FluidScript.Compiler.SyntaxTree.IfStatement">
            <summary>
            If condition syntax 
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.SyntaxTree.IfStatement.Condition">
            <summary>
            Condition
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.SyntaxTree.IfStatement.Then">
            <summary>
            True
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.SyntaxTree.IfStatement.Else">
            <summary>
            False
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.IfStatement.#ctor(FluidScript.Compiler.SyntaxTree.Expression,FluidScript.Compiler.SyntaxTree.Statement,FluidScript.Compiler.SyntaxTree.Statement)">
            <summary>
            Initializes new <see cref="T:FluidScript.Compiler.SyntaxTree.IfStatement"/>
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.IfStatement.Accept(FluidScript.Compiler.IStatementVisitor)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.IfStatement.GenerateCode(FluidScript.Compiler.Emit.MethodBodyGenerator)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.IfStatement.ToString">
            <inheritdoc/>
        </member>
        <member name="T:FluidScript.Compiler.SyntaxTree.LabeledStatement">
            <summary>
            Labeled statement 
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.SyntaxTree.LabeledStatement.Name">
            <summary>
            Label name
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.SyntaxTree.LabeledStatement.Target">
            <summary>
            Target
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.LabeledStatement.#ctor(System.String,FluidScript.Compiler.SyntaxTree.Expression)">
            <summary>
            Initializes new <see cref="T:FluidScript.Compiler.SyntaxTree.LabeledStatement"/>
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.LabeledStatement.ToString">
            <inheritdoc/>
        </member>
        <member name="T:FluidScript.Compiler.SyntaxTree.LoopStatement">
            <summary>
            Loop Statement
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.LoopStatement.#ctor(FluidScript.Compiler.SyntaxTree.Statement,FluidScript.Compiler.SyntaxTree.StatementType)">
            <summary>
            Initializes a <see cref="T:FluidScript.Compiler.SyntaxTree.LoopStatement"/>
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.SyntaxTree.LoopStatement.Initialization">
            <summary>
            Initialization
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.SyntaxTree.LoopStatement.Condition">
            <summary>
            Condition statement
            </summary>
        </member>
        <member name="P:FluidScript.Compiler.SyntaxTree.LoopStatement.Increments">
            <summary>
            Increment or decrement operation
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.LoopStatement.Accept(FluidScript.Compiler.IStatementVisitor)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.LoopStatement.ToString">
            <inheritdoc/>
        </member>
        <member name="T:FluidScript.Compiler.SyntaxTree.ReturnOrThrowStatement">
            <summary>
            Return statement
            </summary>
        </member>
        <member name="F:FluidScript.Compiler.SyntaxTree.ReturnOrThrowStatement.Value">
            <summary>
            return expression
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.ReturnOrThrowStatement.#ctor(FluidScript.Compiler.SyntaxTree.Expression,FluidScript.Compiler.SyntaxTree.StatementType)">
            <summary>
            Initializes new <see cref="T:FluidScript.Compiler.SyntaxTree.ReturnOrThrowStatement"/>
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.ReturnOrThrowStatement.Accept(FluidScript.Compiler.IStatementVisitor)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.ReturnOrThrowStatement.GenerateCode(FluidScript.Compiler.Emit.MethodBodyGenerator)">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.SyntaxTree.ReturnOrThrowStatement.ToString">
            <inheritdoc/>
        </member>
        <member name="F:FluidScript.Compiler.SyntaxTree.StatementType.For">
            <summary>
            for and while
            </summary>
        </member>
        <member name="T:FluidScript.Compiler.IExpressionVisitor`1">
            <summary>
            Expression Visitor
            </summary>
            <typeparam name="TResult">Return Type</typeparam>
        </member>
        <member name="M:FluidScript.Compiler.IExpressionVisitor`1.Default(FluidScript.Compiler.SyntaxTree.Expression)">
            <summary>
            Any Expressions
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.IExpressionVisitor`1.VisitUnary(FluidScript.Compiler.SyntaxTree.UnaryExpression)">
            <summary>
            Unary Expressions
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.IExpressionVisitor`1.VisitInstanceOf(FluidScript.Compiler.SyntaxTree.InstanceOfExpression)">
            <summary>
            Instance of 
            </summary>
            <param name="instanceOfExpression"></param>
            <returns></returns>
        </member>
        <member name="M:FluidScript.Compiler.IExpressionVisitor`1.VisitConvert(FluidScript.Compiler.SyntaxTree.ConvertExpression)">
            <summary>
            Convert Expression &lt;int&gt;
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:FluidScript.Compiler.IExpressionVisitor`1.VisitNew(FluidScript.Compiler.SyntaxTree.NewExpression)">
            <summary>
            New Expression
            </summary>
            <param name="node">Node</param>
            <returns>Resolved value</returns>
        </member>
        <member name="M:FluidScript.Compiler.IExpressionVisitor`1.VisitSizeOf(FluidScript.Compiler.SyntaxTree.SizeOfExpression)">
            <summary>
            Size of expression
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.IExpressionVisitor`1.VisitBinary(FluidScript.Compiler.SyntaxTree.BinaryExpression)">
            <summary>
            Binary Expression
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.IExpressionVisitor`1.VisitAnonymousObject(FluidScript.Compiler.SyntaxTree.AnonymousObjectExpression)">
            <summary>
            AnonymousObject Expression
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.IExpressionVisitor`1.VisitAnonymousFunction(FluidScript.Compiler.SyntaxTree.AnonymousFunctionExpression)">
            <summary>
            AnonymousFunction Expression
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.IExpressionVisitor`1.VisitArrayLiteral(FluidScript.Compiler.SyntaxTree.ArrayListExpression)">
            <summary>
            Array Literal
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.IExpressionVisitor`1.VisitAssignment(FluidScript.Compiler.SyntaxTree.AssignmentExpression)">
            <summary>
            Assignment Expression
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.IExpressionVisitor`1.VisitMember(FluidScript.Compiler.SyntaxTree.MemberExpression)">
            <summary>
            Visit Member access
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.IExpressionVisitor`1.VisitMember(FluidScript.Compiler.SyntaxTree.NameExpression)">
            <summary>
            Visit Name (Identifier) expression
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.IExpressionVisitor`1.VisitCall(FluidScript.Compiler.SyntaxTree.InvocationExpression)">
            <summary>
            Visit Method Call
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.IExpressionVisitor`1.VisitThis(FluidScript.Compiler.SyntaxTree.ThisExpression)">
            <summary>
            Visit this
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.IExpressionVisitor`1.VisitSuper(FluidScript.Compiler.SyntaxTree.SuperExpression)">
            <summary>
            Visit super
            </summary>
            <param name="node"></param>
            <returns>Result</returns>
        </member>
        <member name="M:FluidScript.Compiler.IExpressionVisitor`1.VisitDeclaration(FluidScript.Compiler.SyntaxTree.VariableDeclarationExpression)">
            <summary>
            Visit Declaration
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.IExpressionVisitor`1.VisitLiteral(FluidScript.Compiler.SyntaxTree.LiteralExpression)">
            <summary>
            Visit Literal
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.IExpressionVisitor`1.VisitTernary(FluidScript.Compiler.SyntaxTree.TernaryExpression)">
            <summary>
            Visit ternary expression
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.IExpressionVisitor`1.VisitIndex(FluidScript.Compiler.SyntaxTree.IndexExpression)">
            <summary>
            Visit Indexed Argument expression
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.IExpressionVisitor`1.VisitNull(FluidScript.Compiler.SyntaxTree.NullExpression)">
            <summary>
            Visit Null
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.IExpressionVisitor`1.VisitNullPropegator(FluidScript.Compiler.SyntaxTree.NullPropegatorExpression)">
            <summary>
            Visit Null Propagator
            </summary>
        </member>
        <member name="T:FluidScript.Compiler.IStatementVisitor">
            <summary>
            Statement visitor
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.IStatementVisitor.VisitExpression(FluidScript.Compiler.SyntaxTree.ExpressionStatement)">
            <summary>
            Expression statemenr
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.IStatementVisitor.VisitReturn(FluidScript.Compiler.SyntaxTree.ReturnOrThrowStatement)">
            <summary>
            Visit return statement
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.IStatementVisitor.VisitBlock(FluidScript.Compiler.SyntaxTree.BlockStatement)">
            <summary>
            Visit block
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.IStatementVisitor.VisitDeclaration(FluidScript.Compiler.SyntaxTree.LocalDeclarationStatement)">
            <summary>
            Visit variable declaration
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.IStatementVisitor.VisitContinue(FluidScript.Compiler.SyntaxTree.ContinueStatement)">
            <summary>
            Visit Continue statement
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.IStatementVisitor.VisitBreak(FluidScript.Compiler.SyntaxTree.BreakStatement)">
            <summary>
            Visit break statement
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:FluidScript.Compiler.IStatementVisitor.VisitLoop(FluidScript.Compiler.SyntaxTree.LoopStatement)">
            <summary>
            Visit loop
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.IStatementVisitor.VisitIf(FluidScript.Compiler.SyntaxTree.IfStatement)">
            <summary>
            If Condition
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.TypeProvider.Find(System.TypeCode)">
            <summary>
            UnderlyingSystemType for <paramref name="typeCode"/>
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.ITextSource.ReadChar">
            <summary>
            Read next char and advance pos to next
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.ITextSource.PeekChar">
            <summary>
            Peek next char
            </summary>
        </member>
        <member name="M:FluidScript.Compiler.ITextSource.SkipTo(System.Char)">
            <summary>
            Skip current pos to char <paramref name="c"/>
            </summary>
            <param name="c">character to move pos</param>
        </member>
        <member name="M:FluidScript.Compiler.ITextSource.Skip(System.Char[])">
            <summary>
            Skip the specified <paramref name="c"/> values
            </summary>
            <param name="c">the charecters to skip</param>
        </member>
        <member name="M:FluidScript.Compiler.ITextSource.FallBack">
            <summary>
            Revert to pos-1
            </summary>
            <returns>Current Char in the position</returns>
        </member>
        <member name="M:FluidScript.Compiler.StreamSource.Skip(System.Char[])">
            <inheritdoc/>
        </member>
        <member name="M:FluidScript.Compiler.TextSource.Skip(System.Char[])">
            <inheritdoc/>
        </member>
        <member name="T:FluidScript.Runtime.Closure">
            <summary>
            Passing Runtime arguments of bounded functions for lamda
            </summary>
        </member>
        <member name="T:FluidScript.Runtime.DynamicObject">
            <summary>
            Dynamic Runtime Object
            </summary>
        </member>
        <member name="P:FluidScript.Runtime.DynamicObject.Item(FluidScript.String)">
            <summary>
            Getter and Setter of variables
            </summary>
        </member>
        <member name="M:FluidScript.Runtime.DynamicObject.TryGetMember(System.String,FluidScript.Runtime.LocalVariable@)">
            <summary>
            Get current context variable
            </summary>
        </member>
        <member name="M:FluidScript.Runtime.DynamicObject.Add(System.String,System.Object)">
            <summary>
            Replaces specific value if key exist
            </summary>
        </member>
        <member name="T:FluidScript.Runtime.ICompileProvider">
            <summary>
            Compile provider for Expression
            </summary>
        </member>
        <member name="T:FluidScript.GlobalObject">
            <summary>
            Global object for runtime
            </summary>
        </member>
        <member name="P:FluidScript.GlobalObject.Instance">
            <summary>
            Global target for compilation
            </summary>
        </member>
        <member name="M:FluidScript.GlobalObject.Print(System.Object)">
            <summary>
            Print specified object <paramref name="value"/>
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:FluidScript.GlobalObject.Length(System.Collections.IEnumerable)">
            <summary>
            Get the length of <paramref name="value"/>
            </summary>
        </member>
        <member name="M:FluidScript.GlobalObject.Range(FluidScript.Integer,FluidScript.Integer)">
            <summary>
             Generates a sequence of integral numbers within a specified range.
            </summary>
            <param name="start">The value of the first integer in the sequence.</param>
            <param name="count"> The number of sequential integers to generate.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> in C# or IEnumerable(Of Int32) in Visual Basic that contains
             a range of sequential integral numbers.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">count is less than 0.-or-start + count -1 is larger than System.Int32.MaxValue.</exception>
        </member>
        <member name="M:FluidScript.GlobalObject.Range(FluidScript.Integer,FluidScript.Integer,FluidScript.Integer)">
            <summary>
             Generates a sequence of integral numbers within a specified range.
            </summary>
            <param name="start">The value of the first integer in the sequence.</param>
            <param name="count"> The number of sequential integers to generate.</param>
            <param name="increment">The value of increment </param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> in C# or IEnumerable (Of Int32) in Visual Basic that contains
             a range of sequential integral numbers.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">count is less than 0.-or-start + count -1 is larger than System.Int32.MaxValue.</exception>
        </member>
        <member name="M:FluidScript.GlobalObject.ParseInt(FluidScript.String)">
            <summary>
            Converts String to <see cref="T:FluidScript.Integer"/>
            </summary>
        </member>
        <member name="M:FluidScript.GlobalObject.ParseNumber(FluidScript.String)">
            <summary>
            Converts String to <see cref="T:FluidScript.Double"/>
            </summary>
        </member>
        <member name="M:FluidScript.Extensions.EnumerableExtensions.Iterate``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Iterate items
            </summary>
        </member>
        <member name="M:FluidScript.Extensions.EnumerableExtensions.Iterate``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>
            Iterate items
            </summary>
        </member>
        <member name="M:FluidScript.Extensions.MemberExtensions.IsEquals(FluidScript.Compiler.Emit.IMember,System.String,System.Reflection.BindingFlags)">
            <summary>
            Matches generating argument 
            </summary>
            <param name="member"></param>
            <param name="name"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:FluidScript.Extensions.MemberExtensions.BindingFlagsMatch(FluidScript.Compiler.Emit.IMember,System.Reflection.BindingFlags)">
            <summary>
            Matches generating argument 
            </summary>
            <param name="member"></param>
            <param name="name"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
    </members>
</doc>
